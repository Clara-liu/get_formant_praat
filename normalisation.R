# This is a function for interval wise normalisation 
# The function can be used on unaligned data generated by the get_formant praat script
 

normalise <- function(df, points_per_int, var_vec) {
  words<- levels(droplevels(df[, 'Rep']))
  speakers<- levels(droplevels(df[,'Speaker']))
  ints<- levels(droplevels(df[,'Interval']))
  colNames<- c('Time', 'NormTime', 'Rep', 'Word', 'Interval','Speaker', var_vec)
  normDf<- setNames(data.frame(matrix(ncol = length(colNames), nrow = 0), stringsAsFactors=FALSE), colNames)
  r<- 1
  for (s in speakers){
    for (w in words){
      for (i in 1:length(ints)){
        currentDf<- df[df$Speaker == s & df$Rep == w & df$Interval == ints[i],]
        if (nrow(currentDf)>0){
          currentWord<- toString(currentDf[1,'Word'])
          rownames(currentDf)<- NULL
          start <- currentDf[1,'Time']
          end <- currentDf[nrow(currentDf),'Time']
          totalDur<- end - start
          timeStep<- totalDur/(points_per_int-1)
          timePoints<-seq(from = start, to = end, by = timeStep)
          for (t in 1:length(timePoints)){
            currentTime<- timePoints[t]
            currentNormTime<- t + points_per_int*(i-1)
            newValues<- list()
            for (v in 1:length(var_vec)){
              if (is.na(currentDf[1, var_vec[v]])){
                newValues[[v]]<-NA 
              }
              else {
                if (t == 1) {
                  newValues[[v]]<-currentDf[1,var_vec[v]]
                }
                else if (t == length(timePoints)){
                  newValues[[v]]<-currentDf[nrow(currentDf),var_vec[v]]
                }
                else{
                  time_pre<- tail(currentDf[currentDf$Time <= currentTime,]$Time,1)
                  time_post<- head(currentDf[currentDf$Time > currentTime,]$Time,1)
                  value_pre<- tail(currentDf[currentDf$Time <= currentTime,][var_vec[v]],1)
                  value_post<- head(currentDf[currentDf$Time > currentTime,][var_vec[v]],1)
                  
                  newValues[[v]]<- value_pre + ((currentTime-time_pre)*(value_post-value_pre))/(time_post-time_pre)
                }
              }
            }
            newRow<- append(list(currentTime, currentNormTime, w, currentWord, ints[i], s), newValues)
            normDf[r,]<- newRow
            r<- r + 1
          }
        }
      }
    }
  }
  for (v in var_vec){
    normDf[v]<- unlist(normDf[v])
  }
  return(normDf)
}